import { mkdir, rm, writeFile } from 'fs/promises';
import { join, resolve } from 'path';
import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import { ApiReportIndexer } from '../src/services/api-indexer.js';

/**
 * Helper to wrap code in the API report markdown format
 */
function makeReport(tsCode: string): string {
  return `## API Report File for "test-lib"

> Do not edit this file.

\`\`\`ts

${tsCode}
\`\`\`
`;
}

describe('ApiReportIndexer', () => {
  const fixtureDir = join(process.cwd(), 'tests', 'fixtures', 'api-report');

  beforeEach(async () => {
    await mkdir(fixtureDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(fixtureDir, { recursive: true, force: true });
  });

  describe('parsing basics', () => {
    it('should extract a public interface', async () => {
      const report = makeReport(`
// @public
export interface Point {
    x: number;
    y: number;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('Point');
      expect(symbols[0].kind).toBe('interface');
      expect(symbols[0].importPath).toBe('ng-diagram');
      expect(symbols[0].signature).toContain('interface Point');
      expect(symbols[0].signature).toContain('x: number');
      expect(symbols[0].signature).toContain('y: number');
    });

    it('should extract a public class', async () => {
      const report = makeReport(`
// @public
export class MyService {
    doSomething(): void;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('MyService');
      expect(symbols[0].kind).toBe('class');
    });

    it('should extract a public function', async () => {
      const report = makeReport(`
// @public
export function provideNgDiagram(): Provider[];
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('provideNgDiagram');
      expect(symbols[0].kind).toBe('function');
      expect(symbols[0].signature).toBe('function provideNgDiagram(): Provider[];');
    });

    it('should extract a public type alias', async () => {
      const report = makeReport(`
// @public
export type PortSide = 'top' | 'right' | 'bottom' | 'left';
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('PortSide');
      expect(symbols[0].kind).toBe('type');
    });

    it('should extract a public const', async () => {
      const report = makeReport(`
// @public @deprecated (undocumented)
export const BaseEdgeLabelComponent: typeof NgDiagramBaseEdgeLabelComponent;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('BaseEdgeLabelComponent');
      expect(symbols[0].kind).toBe('const');
      expect(symbols[0].jsDoc).toBe('@deprecated');
    });

    it('should extract multiple symbols from a single report', async () => {
      const report = makeReport(`
// @public
export interface Point {
    x: number;
    y: number;
}

// @public
export function doStuff(): void;

// @public
export type Name = string;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(3);
      expect(symbols.map((s) => s.name)).toEqual(['Point', 'doStuff', 'Name']);
    });
  });

  describe('skips non-public', () => {
    it('should skip @internal declarations', async () => {
      const report = makeReport(`
// @internal
export type AppMiddlewares = typeof BUILTIN_MIDDLEWARES;

// @public
export interface Point {
    x: number;
    y: number;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('Point');
    });

    it('should skip @beta declarations', async () => {
      const report = makeReport(`
// @beta
export function betaFunction(): void;

// @public
export function stableFunction(): void;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('stableFunction');
    });

    it('should skip @internal with Warning comment prefix', async () => {
      const report = makeReport(`
// Warning: (ae-internal-missing-underscore) The name "AppMiddlewares" should be prefixed with an underscore
//
// @internal
export type AppMiddlewares = typeof BUILTIN_MIDDLEWARES;

// @public
export interface Size {
    width: number;
    height: number;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('Size');
    });

    it('should skip import lines', async () => {
      const report = makeReport(`
import { Provider } from '@angular/core';
import * as i0 from '@angular/core';

// @public
export function provideNgDiagram(): Provider[];
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('provideNgDiagram');
    });
  });

  describe('multi-line declarations', () => {
    it('should handle multi-line interfaces with nested braces', async () => {
      const report = makeReport(`
// @public
export interface EdgeRoutingConfig {
    [edgeRoutingName: string]: Record<string, unknown> | undefined;
    bezier?: {
        bezierControlOffset?: number;
    };
    defaultRouting: string;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('EdgeRoutingConfig');
      expect(symbols[0].signature).toContain('bezierControlOffset');
      expect(symbols[0].signature).toContain('defaultRouting: string');
    });

    it('should handle classes with methods and properties', async () => {
      const report = makeReport(`
// @public
export class NgDiagramModelService {
    constructor();
    addEdges(edges: Edge[]): void;
    addNodes(nodes: Node[]): void;
    readonly edges: Signal<Edge[]>;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].kind).toBe('class');
      expect(symbols[0].signature).toContain('addEdges(edges: Edge[]): void');
      expect(symbols[0].signature).toContain('readonly edges: Signal<Edge[]>');
    });
  });

  describe('single-line declarations', () => {
    it('should handle single-line type alias', async () => {
      const report = makeReport(`
// @public
export type PortSide = 'top' | 'right' | 'bottom' | 'left';
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].signature).toBe("type PortSide = 'top' | 'right' | 'bottom' | 'left';");
    });

    it('should handle single-line const', async () => {
      const report = makeReport(`
// @public
export const MY_TOKEN: InjectionToken<string>;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].signature).toBe('const MY_TOKEN: InjectionToken<string>;');
    });

    it('should handle single-line function', async () => {
      const report = makeReport(`
// @public
export function configureShortcuts(userShortcuts: ShortcutDefinition[], baseShortcuts?: ShortcutDefinition[]): ShortcutDefinition[];
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].signature).toBe(
        'function configureShortcuts(userShortcuts: ShortcutDefinition[], baseShortcuts?: ShortcutDefinition[]): ShortcutDefinition[];'
      );
    });
  });

  describe('re-export handling', () => {
    it('should rename symbol via export { X as Y }', async () => {
      const report = makeReport(`
// @public
type Node_2<T extends DataObject = DataObject> = SimpleNode<T> | GroupNode<T>;
export { Node_2 as Node }
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toHaveLength(1);
      expect(symbols[0].name).toBe('Node');
      expect(symbols[0].kind).toBe('type');
      expect(symbols[0].signature).toContain('SimpleNode<T> | GroupNode<T>');
    });

    it('should not keep the original name after re-export', async () => {
      const report = makeReport(`
// @public
type Node_2<T extends DataObject = DataObject> = SimpleNode<T> | GroupNode<T>;
export { Node_2 as Node }
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      await indexer.buildIndex();

      expect(indexer.getSymbol('Node_2')).toBeUndefined();
      expect(indexer.getSymbol('Node')).toBeDefined();
    });
  });

  describe('signature cleaning', () => {
    it('should remove export prefix from signatures', async () => {
      const report = makeReport(`
// @public
export function provideNgDiagram(): Provider[];
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].signature).not.toMatch(/^export /);
      expect(symbols[0].signature).toMatch(/^function /);
    });

    it('should remove Angular compiler artifact lines', async () => {
      const report = makeReport(`
// @public (undocumented)
export class BoxSelectionDirective {
    ngOnDestroy(): void;
    ngOnInit(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<BoxSelectionDirective, "[ngDiagramBoxSelection]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<BoxSelectionDirective, never>;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].signature).not.toContain('ɵdir');
      expect(symbols[0].signature).not.toContain('ɵfac');
      expect(symbols[0].signature).toContain('ngOnDestroy(): void');
    });

    it('should remove // (undocumented) comments', async () => {
      const report = makeReport(`
// @public (undocumented)
export class MyDirective {
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MyDirective, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MyDirective, never>;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].signature).not.toContain('// (undocumented)');
    });

    it('should remove // @internal comments within bodies', async () => {
      const report = makeReport(`
// @public
export class NgDiagramBackgroundComponent {
    // @internal (undocumented)
    protected isDottedBackground: Signal<boolean>;
    // @internal (undocumented)
    ngAfterContentInit(): void;
    type: InputSignal<"grid" | "dots">;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].signature).not.toContain('// @internal');
    });

    it('should keep // @deprecated comments', async () => {
      const report = makeReport(`
// @public
export interface MiddlewareContext {
    config: FlowConfig;
    // @deprecated
    modelActionType: ModelActionType;
    modelActionTypes: ModelActionTypes;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].signature).toContain('// @deprecated');
      expect(symbols[0].signature).toContain('modelActionType: ModelActionType');
    });
  });

  describe('deprecated tag', () => {
    it('should mark deprecated symbols with jsDoc', async () => {
      const report = makeReport(`
// @public @deprecated (undocumented)
export const BaseEdgeLabelComponent: typeof NgDiagramBaseEdgeLabelComponent;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].jsDoc).toBe('@deprecated');
    });

    it('should not set jsDoc for non-deprecated public symbols', async () => {
      const report = makeReport(`
// @public
export function provideNgDiagram(): Provider[];
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols[0].jsDoc).toBeUndefined();
    });
  });

  describe('getSymbol()', () => {
    it('should return exact match by name', async () => {
      const report = makeReport(`
// @public
export interface Point {
    x: number;
    y: number;
}

// @public
export interface Size {
    width: number;
    height: number;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      await indexer.buildIndex();

      const symbol = indexer.getSymbol('Size');
      expect(symbol).toBeDefined();
      expect(symbol!.name).toBe('Size');
      expect(symbol!.kind).toBe('interface');
    });

    it('should return undefined for unknown name', async () => {
      const report = makeReport(`
// @public
export interface Point {
    x: number;
    y: number;
}
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      await indexer.buildIndex();

      expect(indexer.getSymbol('NonExistent')).toBeUndefined();
    });
  });

  describe('getSymbols()', () => {
    it('should return all indexed symbols', async () => {
      const report = makeReport(`
// @public
export interface Point {
    x: number;
    y: number;
}

// @public
export function doStuff(): void;
`);
      await writeFile(join(fixtureDir, 'report.api.md'), report);
      const indexer = new ApiReportIndexer(join(fixtureDir, 'report.api.md'));
      await indexer.buildIndex();

      expect(indexer.getSymbols()).toHaveLength(2);
    });

    it('should return empty array before buildIndex is called', () => {
      const indexer = new ApiReportIndexer('/nonexistent/path');
      expect(indexer.getSymbols()).toEqual([]);
    });
  });

  describe('error handling', () => {
    it('should return empty array for missing file', async () => {
      const indexer = new ApiReportIndexer(join(fixtureDir, 'does-not-exist.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toEqual([]);
    });

    it('should return empty array for file without code block', async () => {
      await writeFile(join(fixtureDir, 'empty.api.md'), '# No code block here');
      const indexer = new ApiReportIndexer(join(fixtureDir, 'empty.api.md'));
      const symbols = await indexer.buildIndex();

      expect(symbols).toEqual([]);
    });
  });

  describe('integration with real API report', () => {
    it('should parse the real ng-diagram API report', async () => {
      const realReportPath = resolve(process.cwd(), '../../packages/ng-diagram/api-report/ng-diagram.api.md');
      const indexer = new ApiReportIndexer(realReportPath);
      const symbols = await indexer.buildIndex();

      // Should have a reasonable number of symbols
      expect(symbols.length).toBeGreaterThan(20);

      // Key symbols should exist
      const names = symbols.map((s) => s.name);
      expect(names).toContain('provideNgDiagram');
      expect(names).toContain('NgDiagramComponent');
      expect(names).toContain('Edge');
      expect(names).toContain('Node');
      expect(names).toContain('NgDiagramService');
      expect(names).toContain('initializeModel');

      // Internal symbols should not exist
      expect(names).not.toContain('AppMiddlewares');
      expect(names).not.toContain('loggerMiddleware');
      expect(names).not.toContain('NgDiagramMath');
      expect(names).not.toContain('NodeSizeDirective');
    });

    it('should have correct kinds for known symbols', async () => {
      const realReportPath = resolve(process.cwd(), '../../packages/ng-diagram/api-report/ng-diagram.api.md');
      const indexer = new ApiReportIndexer(realReportPath);
      await indexer.buildIndex();

      expect(indexer.getSymbol('provideNgDiagram')?.kind).toBe('function');
      expect(indexer.getSymbol('NgDiagramComponent')?.kind).toBe('class');
      expect(indexer.getSymbol('Edge')?.kind).toBe('interface');
      expect(indexer.getSymbol('Node')?.kind).toBe('type');
      expect(indexer.getSymbol('Point')?.kind).toBe('interface');
    });

    it('should clean Angular artifacts from real class signatures', async () => {
      const realReportPath = resolve(process.cwd(), '../../packages/ng-diagram/api-report/ng-diagram.api.md');
      const indexer = new ApiReportIndexer(realReportPath);
      await indexer.buildIndex();

      const component = indexer.getSymbol('NgDiagramComponent');
      expect(component).toBeDefined();
      expect(component!.signature).not.toContain('ɵcmp');
      expect(component!.signature).not.toContain('ɵfac');
    });
  });
});
