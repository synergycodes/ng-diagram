---
title: Middlewares
description: Understanding how middlewares work in ngDiagram
---

Middlewares provide a powerful plugin architecture for extending ngDiagram behavior. They intercept state changes before they reach the model, allowing you to transform data, add custom logic, and implement features without modifying core code.

## How Middlewares Work

When any change occurs in the diagram (adding nodes, moving elements, changing selections), the change goes through a middleware pipeline before reaching the model. Each middleware can:

- **Inspect** the current state and what's being changed
- **Transform** the data being applied
- **Add** additional changes to the state
- **Cancel** the operation entirely
- **Perform** asynchronous operations

Middlewares execute in sequence, with each middleware receiving the output of the previous one. This creates a powerful composition system where multiple behaviors can be combined.

## Middleware API

### Middleware Action Types

The [`ModelActionType`](/docs/api/types/middleware/modelactiontype/) type lists all possible actions that can trigger middleware execution.
These represent every operation that modifies the diagram state, such as adding nodes, moving elements, deleting selections, resizing, linking, rotating, and more.

### Middleware Interface

Each middleware implements the [`Middleware`](/docs/api/types/middleware/middleware/) interface:

```typescript
interface Middleware<TName extends string = string> {
  name: TName;
  execute: (
    context: MiddlewareContext,
    next: (stateUpdate?: FlowStateUpdate) => Promise<FlowState>,
    cancel: () => void
  ) => Promise<void> | void;
}
```

### Middleware Context

The **context** object passed to middleware functions provides comprehensive access to the diagram state and metadata:

- [`initialState`](/docs/api/types/middleware/middlewarecontext/#initialstate) – The state before any modifications
- [`state`](/docs/api/types/middleware/middlewarecontext/#state) – The current state after all previous modifications.
- [`nodesMap`](/docs/api/types/middleware/middlewarecontext/#nodesmap) / [`edgesMap`](/docs/api/types/middleware/middlewarecontext/#edgesmap) – Maps for quick lookup of nodes and edges by ID
- [`initialNodesMap`](/docs/api/types/middleware/middlewarecontext/#initialnodesmap) / [`initialEdgesMap`](/docs/api/types/middleware/middlewarecontext/#initialedgesmap) – Maps for accessing nodes/edges before any changes
- [`modelActionType`](/docs/api/types/middleware/middlewarecontext/#modelactiontype) – The action that triggered the middleware.
- [`helpers`](/docs/api/types/middleware/middlewarecontext/#helpers) – Utility functions for inspecting what changed
- [`history`](/docs/api/types/middleware/middlewarecontext/#history) – Array of all state updates made by previous middlewares in the chain.
- [`actionStateManager`](/docs/api/types/middleware/middlewarecontext/#actionstatemanager) – Manager for temporary action states.
- [`edgeRoutingManager`](/docs/api/types/middleware/middlewarecontext/#edgeroutingmanager) – Manager for edge routing algorithms.
- [`initialUpdate`](/docs/api/types/middleware/middlewarecontext/#initialupdate) – The initial state update that triggered the middleware chain.
- [`config`](/docs/api/types/middleware/middlewarecontext/#config) – Current diagram configuration.
- [`environment`](/docs/api/types/middleware/middlewarecontext/#environment) – Environment information (browser, rendering engine, etc.).

### Middleware Helpers

The [`helpers`](/docs/api/types/middleware/middlewarecontext/#helpers) object provides optimized functions to inspect all cumulative changes from the initial update and previous middlewares:

- [`checkIfNodeChanged(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifnodechanged) – Was this node modified?
- [`checkIfEdgeChanged(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifedgechanged) – Was this edge modified?
- [`checkIfNodeAdded(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifnodeadded) / [`checkIfNodeRemoved(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifnoderemoved) – Was this node added/removed?
- [`checkIfEdgeAdded(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifedgeadded) / [`checkIfEdgeRemoved(id)`](/docs/api/types/middleware/middlewarehelpers/#checkifedgeremoved) – Was this edge added/removed?
- [`checkIfAnyNodePropsChanged(['prop1', 'prop2'])`](/docs/api/types/middleware/middlewarehelpers/#checkifanynodepropschanged) – Did any node have these properties changed?
- [`checkIfAnyEdgePropsChanged(['prop1', 'prop2'])`](/docs/api/types/middleware/middlewarehelpers/#checkifanyedgepropschanged) – Did any edge have these properties changed?
- [`anyNodesAdded()`](/docs/api/types/middleware/middlewarehelpers/#anynodesadded) / [`anyEdgesAdded()`](/docs/api/types/middleware/middlewarehelpers/#anyedgesadded) – Were any nodes/edges added?
- [`anyNodesRemoved()`](/docs/api/types/middleware/middlewarehelpers/#anynodesremoved) / [`anyEdgesRemoved()`](/docs/api/types/middleware/middlewarehelpers/#anyedgesremoved) – Were any nodes/edges removed?
- [`getAffectedNodeIds(['prop1', 'prop2'])`](/docs/api/types/middleware/middlewarehelpers/#getaffectednodeids) – Get IDs of nodes with specified properties changed.
- [`getAffectedEdgeIds(['prop1', 'prop2'])`](/docs/api/types/middleware/middlewarehelpers/#getaffectededgeids) – Get IDs of edges with specified properties changed.
- [`getAddedNodes()`](/docs/api/types/middleware/middlewarehelpers/#getaddednodes) / [`getAddedEdges()`](/docs/api/types/middleware/middlewarehelpers/#getaddededges) – Get instances of added nodes/edges.
- [`getRemovedNodes()`](/docs/api/types/middleware/middlewarehelpers/#getremovednodes) / [`getRemovedEdges()`](/docs/api/types/middleware/middlewarehelpers/#getremovededges) – Get instances of removed nodes/edges (from initial state).

These helpers allow you to efficiently check what changed during the middleware execution chain.

#### Example: Using Helpers

```typescript
// Example with a middleware that checks if any node was added into a group
export const myMiddleware: Middleware = {
  name: 'group-node-checker',
  execute: async (context, next) => {
    const { helpers } = context;
    if (helpers.checkIfAnyNodePropsChanged(['groupId']).length > 0) {
      const affectedNodeIds = helpers.getAffectedNodeIds(['groupId']);
      console.log('Nodes were added to groups:', affectedNodeIds);
    }

    next(); // Continue to next middleware
  },
};
```

### Middleware History

The [`history`](/docs/api/types/middleware/middlewarecontext/#history) array in the context tracks all state updates made by previous middlewares, including the name of the middleware and the specific state update applied.\
This is useful for auditing or debugging complex middleware chains.

## Managing Middlewares

### Initial Registration

The primary way to configure middlewares is using the [`createMiddlewares`](/docs/api/utilities/createmiddlewares) helper and passing them to the [`<ng-diagram>`](/docs/api/components/ngdiagramcomponent) component:

```typescript
import { createMiddlewares } from 'ng-diagram';

// Use all default middlewares
const middlewares = createMiddlewares((defaults) => defaults);

// Add custom middleware to the chain
const middlewares = createMiddlewares((defaults) => [...defaults, myCustomMiddleware]);

// Remove specific middleware
const middlewares = createMiddlewares((defaults) => defaults.filter((m) => m.name !== 'logger'));
```

Then pass them to your diagram component:

```typescript
@Component({
  template: ` <ng-diagram [model]="model" [config]="config" [middlewares]="middlewares" /> `,
})
export class MyDiagramComponent {
  middlewares = createMiddlewares((defaults) => [...defaults, myMiddleware]);
  // ...
}
```

### Runtime Registration

You can also register and unregister middlewares dynamically using the [`NgDiagramService`](/docs/api/services/ngdiagramservice/).\
 **Note**: This can only be done when the diagram is initialized, which you can check using [`isInitialized`](/docs/api/services/ngdiagramservice/#isinitialized) signal:

```typescript
import { inject } from '@angular/core';
import { NgDiagramService } from 'ng-diagram';

@Component({...})
export class MyComponent {
  private ngDiagram = inject(NgDiagramService);

  addMiddleware() {
    // Check if diagram is initialized first
    if (!this.ngDiagram.isInitialized()) {
      console.warn('Cannot register middleware: diagram not initialized');
      return;
    }

    // Register returns an unregister function
    const unregister = this.ngDiagram.registerMiddleware(myMiddleware);

    // Later you can unregister the middleware by invoking the returned function
    // unregister();
  }

  removeMiddleware() {
    if (!this.ngDiagram.isInitialized()) {
      console.warn('Cannot unregister middleware: diagram not initialized');
      return;
    }

    // You can also unregister the middleware by name
    this.ngDiagram.unregisterMiddleware('my-middleware-name');
  }
}
```

## Creating Custom Middlewares

### Basic Middleware Structure

Here's the basic structure for a custom middleware:

```typescript
import { Middleware } from 'ng-diagram';

export const myMiddleware: Middleware = {
  name: 'my-middleware',
  execute: async (context, next) => {
    const { state, modelActionType } = context;

    // Check if this middleware should run
    if (modelActionType !== 'updateNode') {
      next(); // Pass through without changes
      return;
    }

    // Your custom logic here
    console.log('Nodes being updated:', state.nodes);

    // Continue to next middleware
    next();
  },
};
```

### Example

For a complete example of creating custom middleware, see the [Custom Middleware example](/docs/examples/custom-middleware/) which demonstrates how to implement a read-only mode middleware that prevents certain operations while allowing others.

### Advanced Middleware Features

#### Modifying State

Middlewares can modify the diagram state by passing a [`FlowStateUpdate`](/docs/api/types/middleware/flowstateupdate/) object to `next()`:

```typescript
interface FlowStateUpdate {
  nodesToAdd?: Node[];
  nodesToUpdate?: (Partial<Node> & { id: Node['id'] })[];
  nodesToRemove?: string[];
  edgesToAdd?: Edge[];
  edgesToUpdate?: (Partial<Edge> & { id: Edge['id'] })[];
  edgesToRemove?: string[];
  metadataUpdate?: Partial<Metadata>;
}
```

This allows you to add, update, or remove nodes/edges, and update metadata in a granular way.

#### Example: Rotating New Nodes

```typescript
export const myCustomMiddleware: Middleware = {
  name: 'rotate-middleware',
  execute: async (context, next) => {
    const { helpers } = context;

    // Check if this middleware should run
    if (!helpers.anyNodesAdded()) {
      next(); // Pass through without changes
      return;
    }

    // Rotate all new nodes and change label
    const stateUpdate = {
      nodesToUpdate: context.state.nodes
        .filter((node) => helpers.checkIfNodeAdded(node.id))
        .map((node) => ({
          ...node,
          angle: 45,
          data: { ...node.data, label: `rotated via middleware` },
        })),
    };

    // Continue to next middleware
    next(stateUpdate);
  },
};
```

#### Asynchronous Operations

Middlewares can perform async operations:

```typescript
export const myCustomMiddleware: Middleware = {
  name: 'validation',
  execute: async (context, next, cancel) => {
    const { helpers } = context;

    if (!helpers.anyNodesAdded()) {
      next();
      return;
    }

    // Simulated API validation function
    const validateNodesWithAPI = () => {
      return new Promise<void>((resolve, reject) => {
        setTimeout(() => {
          const isValid = Math.random() > 0.5; // 50% chance of success
          if (isValid) {
            resolve();
          } else {
            reject(new Error('Random validation failure'));
          }
        }, 1000); // 1 second delay — after this time the node will be added if valid, or an alert/error will be displayed if invalid
      });
    };

    try {
      await validateNodesWithAPI();
      next(); // Validation passed
    } catch (error) {
      alert(`Validation failed: ${error}`);
      cancel(); // Cancel the operation
    }
  },
};
```

However, you should avoid long-running async operations in middlewares as they can block the UI.

## Best Practices

### Performance

- **Check conditions early**: Return `next()` immediately if your middleware doesn't need to run
- **Use helpers efficiently**: The helper functions are optimized for checking what changed
- **Avoid heavy computations**: Keep middleware logic lightweight, especially for frequently-triggered actions

### Middleware Ordering

- **Validation middlewares** should run early to fail fast
- **Data transformation middlewares** should run before built-in middlewares that depend on the data
- **Logging middlewares** typically run last to capture the final state
