---
title: Transactions
description: Understanding how transactions work in ngDiagram
---

import { Aside, Badge } from '@astrojs/starlight/components';
import CodeViewer from '@components/code-viewer/code-viewer.astro';

Transactions in ngDiagram provide a mechanism for batching multiple state changes into atomic operation.
This is particularly useful for complex operations that involve multiple nodes and edges, ensuring better performance.

## Usage

The transaction API is straightforward - simply wrap your operations in a callback.

```typescript
this.ngDiagramService.transaction(() => {
  this.ngDiagramModelService.addNodes([node1, node2]);
  this.ngDiagramModelService.addEdges([edge1]);
});
```

## Async Transactions <Badge text="since v0.9.0" variant="tip" />

Transactions support async callbacks, allowing you to perform asynchronous operations like fetching data from a server before modifying the diagram state.

```typescript
await this.ngDiagramService.transaction(async () => {
  // Fetch data from server
  const nodes = await this.nodeService.fetchNodes();

  // Add nodes after data is fetched
  this.ngDiagramModelService.addNodes(nodes);
});

console.log('Transaction complete - all nodes added');
```

The transaction promise resolves after all operations inside the callback are complete and the state has been updated.

## Transaction Options <Badge text="since v0.9.0" variant="tip" />

Transactions accept an optional second parameter for additional configuration.

### waitForMeasurements

When adding nodes or edges, the diagram needs to measure their dimensions before they're fully rendered. By default, the transaction resolves immediately after the state update, before measurements complete.

Use `waitForMeasurements: true` when you need to perform operations that depend on measured values, such as zooming to fit new nodes:

```typescript
// Add nodes and wait for their dimensions to be measured
await this.ngDiagramService.transaction(
  () => {
    this.ngDiagramModelService.addNodes([newNode]);
  },
  { waitForMeasurements: true }
);

// Now safe to zoom - node dimensions are known
this.ngDiagramViewportService.zoomToFit();
```

<Aside type="caution">
  Without `waitForMeasurements`, operations like `zoomToFit()` might not account for newly added elements because their
  dimensions haven't been measured yet.
</Aside>

This works with both sync and async transactions:

```typescript
// Async transaction with measurements
await this.ngDiagramService.transaction(
  async () => {
    const data = await fetchNodeDataFromServer();

    const newNode: Node = {
      id: 'fetched-node',
      type: 'default',
      position: { x: 1000, y: 1000 },
      data,
    };

    this.ngDiagramModelService.addNodes([newNode]);
  },
  { waitForMeasurements: true }
);

// Zoom to include the new node with correct dimensions
this.ngDiagramViewportService.zoomToFit();
```

## How Transactions Work

Understanding how transactions are applied internally helps you write better code and reason about your diagram state changes. When a transaction is committed, operations are executed in a specific sequence to maintain data integrity:

```typescript
stateUpdate.nodesToAdd?.forEach((node) => this.addNode(node));
stateUpdate.edgesToAdd?.forEach((edge) => this.addEdge(edge));
stateUpdate.edgesToRemove?.forEach((id) => this.removeEdge(id));
stateUpdate.nodesToRemove?.forEach((id) => this.removeNode(id));
stateUpdate.nodesToUpdate?.forEach((node) => this.updateNode(node));
stateUpdate.edgesToUpdate?.forEach((edge) => this.updateEdge(edge));

if (stateUpdate.metadataUpdate) {
  this.metadata = { ...this.metadata, ...stateUpdate.metadataUpdate };
}
```

This fixed order ensures that:

- **Nodes are added first**, making them available before edges that might reference them
- **Edges are added next**, after all required nodes exist
- **Edges are removed before nodes**, preventing dangling edge references
- **Nodes are removed after edges**, ensuring no edges point to non-existent nodes
- **Updates are applied after all additions and removals**, ensuring the structure is stable before modifying properties
- **Metadata is merged last**, after all other operations are complete

<Aside type="tip">
  That means operations are **grouped by type** regardless of call order:

**Add nodes → Add edges → Remove edges → Remove nodes → Update nodes → Update edges → Merge metadata**

So call order inside transactions is **not preserved**. For example: [`addNodes([node1])`](/docs/api/services/ngdiagrammodelservice/#addnodes) → [`addEdges([edge1])`](/docs/api/services/ngdiagrammodelservice/#addedges) → [`addNodes([node2])`](/docs/api/services/ngdiagrammodelservice/#addnodes) will execute both node additions together.

</Aside>

## Benefits

### Performance

Transactions batch multiple operations together, reducing the number of state updates and re-renders. Instead of triggering change detection for each individual operation, all changes are applied at once.

### Consistency

All operations within a transaction succeed together, preventing partial state updates that could leave your diagram in an inconsistent state.

## When to Use Transactions

Use transactions for:

- **Complex multi-step operations** - Creating multiple related nodes and edges
- **Bulk operations** - Adding or updating many elements at once
- **Performance optimization** - Reducing the number of state updates
- **Operations requiring measurements** - When you need to zoom to fit or center on newly added elements

## Best Practices

Group related operations together, but avoid making transactions too large or complex:

```typescript
// ✅ Good - related operations grouped together
this.ngDiagramService.transaction(() => {
  this.ngDiagramModelService.addNodes([node1, node2, node3]);
  this.ngDiagramModelService.addEdges([edge1, edge2]);
});

// ❌ Avoid - unrelated operations in same transaction
this.ngDiagramService.transaction(() => {
  this.ngDiagramModelService.addNodes([...]);
  this.updateUserPreferences(); // Unrelated operation
  this.updateDiagramName(); // Another unrelated operation
});

```

Wrap the entire loop in a single transaction instead of starting one for every iteration to minimize overhead

```typescript
// ✅ Good - loop inside transaction
this.ngDiagramService.transaction(() => {
  for (const node of nodes) {
    this.ngDiagramModelService.updateNodeData(node);
  }
});

// ❌ Avoid - transactions inside a loop
for (const node of nodes) {
  this.ngDiagramService.transaction(() => {
    this.ngDiagramModelService.updateNodeData(node); // Each iteration creates a separate transaction
  });
}
```

## Example

<Aside type="note">
  When testing the demo example below, you can see detailed transaction logs in the browser console. This is enabled by setting [`debugMode: true`](/docs/api/types/configuration/flowconfig/#debugmode) in the diagram configuration:
  ```typescript
  config: NgDiagramConfig = {
    debugMode: true,
  };
  ```
  This is particularly useful for understanding the difference between transaction and non-transaction behavior in the interactive demo.
</Aside>

[Read more about global configuration in ngDiagram →](/docs/guides/configuration/)

import Transactions from '@examples/transactions/transactions.astro';

<Transactions />
<CodeViewer dirName="examples/transactions" />

Whether you're building simple diagrams or complex applications, transactions help ensure data consistency and optimal performance.
