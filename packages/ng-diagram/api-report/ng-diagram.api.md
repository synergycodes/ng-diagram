## API Report File for "ng-diagram"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Provider } from '@angular/core';
import { Signal } from '@angular/core';
import { Type } from '@angular/core';
import { WritableSignal } from '@angular/core';

// @public
export interface ActionState {
    copyPaste?: CopyPasteActionState;
    dragging?: DraggingActionState;
    highlightGroup?: HighlightGroupActionState;
    linking?: LinkingActionState;
    panning?: PanningActionState;
    resize?: ResizeActionState;
    rotation?: RotationActionState;
}

// @public
export class ActionStateManager {
    constructor(eventManager: EventManager);
    clearCopyPaste(): void;
    clearDragging(): void;
    clearHighlightGroup(): void;
    clearLinking(): void;
    clearPanning(): void;
    clearResize(): void;
    clearRotation(): void;
    get copyPaste(): CopyPasteActionState | undefined;
    set copyPaste(value: CopyPasteActionState | undefined);
    get dragging(): DraggingActionState | undefined;
    set dragging(value: DraggingActionState | undefined);
    getState(): Readonly<ActionState>;
    get highlightGroup(): HighlightGroupActionState | undefined;
    set highlightGroup(value: HighlightGroupActionState | undefined);
    isDragging(): boolean;
    isLinking(): boolean;
    isPanning(): boolean;
    isResizing(): boolean;
    isRotating(): boolean;
    get linking(): LinkingActionState | undefined;
    set linking(value: LinkingActionState | undefined);
    get panning(): PanningActionState | undefined;
    set panning(value: PanningActionState | undefined);
    get resize(): ResizeActionState | undefined;
    set resize(value: ResizeActionState | undefined);
    get rotation(): RotationActionState | undefined;
    set rotation(value: RotationActionState | undefined);
}

// Warning: (ae-internal-missing-underscore) The name "AppMiddlewares" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type AppMiddlewares = typeof BUILTIN_MIDDLEWARES;

// @public
export interface BackgroundConfig {
    cellSize?: Size;
    dotSpacing?: number;
    majorLinesFrequency?: {
        x: number;
        y: number;
    };
}

// @public @deprecated (undocumented)
export const BaseEdgeLabelComponent: typeof NgDiagramBaseEdgeLabelComponent;

// @public
export interface BasePaletteItemData {
    label: string;
}

// @public
export interface BoxSelectionConfig {
    partialInclusion?: boolean;
    realtime?: boolean;
}

// @public (undocumented)
export class BoxSelectionDirective implements OnInit, OnDestroy {
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    onPointerDown(event: PointerInputEvent): void;
    // (undocumented)
    onPointerUp: (event: PointerEvent) => void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<BoxSelectionDirective, "[ngDiagramBoxSelection]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<BoxSelectionDirective, never>;
}

// @public
export interface ClipboardPastedEvent {
    edges: Edge[];
    nodes: Node_2[];
}

// @public
export function configureShortcuts(userShortcuts: ShortcutDefinition[], baseShortcuts?: ShortcutDefinition[]): ShortcutDefinition[];

// @public
export interface CopyPasteActionState {
    copiedEdges: Edge[];
    copiedNodes: Node_2[];
}

// Warning: (ae-incompatible-release-tags) The symbol "createMiddlewares" is marked as @public, but its signature references "AppMiddlewares" which is marked as @internal
//
// @public
export function createMiddlewares<TMiddlewares extends MiddlewareChain = AppMiddlewares>(middlewares: (defaults: AppMiddlewares) => TMiddlewares): TMiddlewares;

// @public (undocumented)
export class CursorPositionTrackerDirective {
    // (undocumented)
    onMouseMove(event: MouseEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CursorPositionTrackerDirective, "[ngDiagramCursorPositionTracker]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CursorPositionTrackerDirective, never>;
}

// @public
export interface DiagramEventMap {
    clipboardPasted: ClipboardPastedEvent;
    diagramInit: DiagramInitEvent;
    edgeDrawn: EdgeDrawnEvent;
    groupMembershipChanged: GroupMembershipChangedEvent;
    nodeResized: NodeResizedEvent;
    paletteItemDropped: PaletteItemDroppedEvent;
    selectionChanged: SelectionChangedEvent;
    selectionMoved: SelectionMovedEvent;
    selectionRemoved: SelectionRemovedEvent;
    selectionRotated: SelectionRotatedEvent;
    viewportChanged: ViewportChangedEvent;
}

// @public
export interface DiagramInitEvent {
    edges: Edge[];
    nodes: Node_2[];
    viewport: Viewport;
}

// @public (undocumented)
export class DiagramSelectionDirective extends ObjectSelectionDirective {
    // (undocumented)
    readonly targetData: InputSignal<Edge<object> | Node_2 | undefined>;
    // (undocumented)
    targetType: BasePointerInputEvent['targetType'];
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<DiagramSelectionDirective, never, never, { "targetData": { "alias": "targetData"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DiagramSelectionDirective, never>;
}

// @public
export interface DraggingActionState {
    accumulatedDeltas: Map<string, Point>;
    modifiers: InputModifiers;
}

// @public
export interface Edge<T extends DataObject = DataObject> {
    // (undocumented)
    readonly computedZIndex?: number;
    data: T;
    id: string;
    // (undocumented)
    readonly measuredLabels?: EdgeLabel[];
    points?: Point[];
    routing?: EdgeRoutingName;
    routingMode?: RoutingMode;
    selected?: boolean;
    source: string;
    sourceArrowhead?: string;
    sourcePort?: string;
    sourcePosition?: Point;
    target: string;
    targetArrowhead?: string;
    targetPort?: string;
    targetPosition?: Point;
    temporary?: boolean;
    type?: string;
    zOrder?: number;
}

// @public
export interface EdgeDrawnEvent {
    edge: Edge;
    source: Node_2;
    sourcePort?: string;
    target: Node_2;
    targetPort?: string;
}

// @public
export interface EdgeLabel {
    id: string;
    position?: Point;
    positionOnEdge: number;
    size?: Size;
}

// @public
export interface EdgeRouting {
    computePointOnPath?(points: Point[], percentage: number): Point;
    computePoints(context: EdgeRoutingContext, config?: EdgeRoutingConfig): Point[];
    computeSvgPath(points: Point[], config?: EdgeRoutingConfig): string;
    name: string;
}

// @public
export interface EdgeRoutingConfig {
    [edgeRoutingName: string]: Record<string, unknown> | EdgeRoutingName | undefined;
    bezier?: {
        bezierControlOffset?: number;
    };
    defaultRouting: EdgeRoutingName;
    orthogonal?: {
        firstLastSegmentLength?: number;
        maxCornerRadius?: number;
    };
}

// @public
export interface EdgeRoutingContext {
    edge: Edge;
    sourceNode?: Node_2;
    sourcePoint: PortLocation;
    sourcePort?: Port;
    targetNode?: Node_2;
    targetPoint: PortLocation;
    targetPort?: Port;
}

// @public
export class EdgeRoutingManager {
    // @internal
    constructor(defaultEdgeRouting: EdgeRoutingName, getRoutingConfiguration: () => EdgeRoutingConfig);
    computePath(routingName: EdgeRoutingName | undefined, points: Point[]): string;
    computePointOnPath(routingName: EdgeRoutingName | undefined, points: Point[], percentage: number): Point;
    computePoints(routingName: EdgeRoutingName | undefined, context: EdgeRoutingContext): Point[];
    getDefaultRouting(): EdgeRoutingName;
    getRegisteredRoutings(): EdgeRoutingName[];
    getRouting(name: EdgeRoutingName): EdgeRouting | undefined;
    hasRouting(name: EdgeRoutingName): boolean;
    registerRouting(routing: EdgeRouting): void;
    setDefaultRouting(name: EdgeRoutingName): void;
    unregisterRouting(name: EdgeRoutingName): void;
}

// @public
export type EdgeRoutingName = LooseAutocomplete<BuiltInEdgeRoutingName>;

// @public (undocumented)
export class EdgeSelectionDirective extends ObjectSelectionDirective {
    // (undocumented)
    readonly targetData: InputSignal<Edge<object> | Node_2 | undefined>;
    // (undocumented)
    targetType: BasePointerInputEvent['targetType'];
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<EdgeSelectionDirective, never, never, { "targetData": { "alias": "targetData"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<EdgeSelectionDirective, never>;
}

// @public
export interface EnvironmentInfo {
    browser: LooseAutocomplete<'Chrome' | 'Firefox' | 'Safari' | 'Edge' | 'Opera' | 'IE' | 'Other'> | null;
    generateId: () => string;
    now: () => number;
    os: LooseAutocomplete<'MacOS' | 'Windows' | 'Linux' | 'iOS' | 'Android' | 'Unknown'> | null;
    runtime: LooseAutocomplete<'web' | 'node' | 'other'> | null;
}

// @public
export interface FlowConfig {
    background: BackgroundConfig;
    boxSelection: BoxSelectionConfig;
    computeEdgeId: () => string;
    computeNodeId: () => string;
    debugMode: boolean;
    edgeRouting: EdgeRoutingConfig;
    grouping: GroupingConfig;
    hideWatermark?: boolean;
    linking: LinkingConfig;
    nodeDraggingEnabled: boolean;
    nodeRotation: NodeRotationConfig;
    resize: ResizeConfig;
    selectionMoving: SelectionMovingConfig;
    shortcuts: ShortcutDefinition[];
    snapping: SnappingConfig;
    viewportPanningEnabled: boolean;
    virtualization: VirtualizationConfig;
    zIndex: ZIndexConfig;
    zoom: ZoomConfig;
}

// @public
export interface FlowState {
    edges: Edge[];
    metadata: Metadata;
    nodes: Node_2[];
}

// @public
export interface FlowStateUpdate {
    edgesToAdd?: Edge[];
    edgesToRemove?: string[];
    edgesToUpdate?: (Partial<Edge> & {
        id: Edge['id'];
    })[];
    metadataUpdate?: Partial<Metadata>;
    nodesToAdd?: Node_2[];
    nodesToRemove?: string[];
    nodesToUpdate?: (Partial<Node_2> & {
        id: Node_2['id'];
    })[];
    // @internal
    renderedEdgeIds?: string[];
    // @internal
    renderedNodeIds?: string[];
}

// @public
export interface GroupingConfig {
    canGroup: (node: Node_2, group: Node_2) => boolean;
}

// @public
export interface GroupMembershipChangedEvent {
    grouped: {
        nodes: Node_2[];
        targetGroup: GroupNode;
    }[];
    ungrouped: Node_2[];
}

// @public
export interface GroupNode<T extends DataObject = DataObject> extends SimpleNode<T> {
    highlighted: boolean;
    isGroup: true;
}

// @public
export type GroupNodeData<Data extends object = BasePaletteItemData> = SimpleNodeData<Data> & Pick<GroupNode, 'isGroup'>;

// @public
export interface HighlightGroupActionState {
    highlightedGroupId: string | null;
}

// @public
export function initializeModel(model?: Partial<Model>, injector?: Injector): SignalModelAdapter;

// @public
export interface InputModifiers {
    meta: boolean;
    primary: boolean;
    secondary: boolean;
    shift: boolean;
}

// @public
export type KeyboardActionName = KeyboardMoveSelectionAction | KeyboardPanAction | KeyboardZoomAction | Extract<InputEventName, 'cut' | 'paste' | 'copy' | 'deleteSelection' | 'undo' | 'redo' | 'selectAll'>;

// @public (undocumented)
export class KeyboardInputsDirective {
    // (undocumented)
    onKeyDown(event: KeyboardEvent): void;
    // (undocumented)
    onPointerDown(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<KeyboardInputsDirective, "[ngDiagramKeyboardInputs]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<KeyboardInputsDirective, never>;
}

// @public
export type KeyboardMoveSelectionAction = 'keyboardMoveSelectionUp' | 'keyboardMoveSelectionDown' | 'keyboardMoveSelectionLeft' | 'keyboardMoveSelectionRight';

// @public
export type KeyboardPanAction = 'keyboardPanUp' | 'keyboardPanDown' | 'keyboardPanLeft' | 'keyboardPanRight';

// @public
export interface KeyboardShortcutBinding {
    key: string;
    modifiers?: Partial<InputModifiers>;
}

// @public
export interface KeyboardShortcutDefinition {
    actionName: KeyboardActionName;
    bindings: (KeyboardShortcutBinding | ModifierOnlyShortcutBinding)[];
}

// @public
export type KeyboardZoomAction = 'keyboardZoomIn' | 'keyboardZoomOut';

// @public
export interface LinkingActionState {
    sourceNodeId: string;
    sourcePortId: string;
    temporaryEdge: Edge | null;
}

// @public
export interface LinkingConfig {
    edgePanningEnabled: boolean;
    edgePanningForce: number;
    edgePanningThreshold: number;
    finalEdgeDataBuilder: (defaultFinalEdgeData: Edge) => Edge;
    portSnapDistance: number;
    temporaryEdgeDataBuilder: (defaultTemporaryEdgeData: Edge) => Edge;
    validateConnection: (source: Node_2 | null, sourcePort: Port | null, target: Node_2 | null, targetPort: Port | null) => boolean;
}

// @public (undocumented)
export class LinkingInputDirective implements OnDestroy {
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    onPointerDown($event: PointerInputEvent): void;
    // (undocumented)
    onPointerMove: ($event: PointerInputEvent) => void;
    // (undocumented)
    onPointerUp: ($event: PointerInputEvent) => void;
    // (undocumented)
    portId: InputSignal<string>;
    // (undocumented)
    setTargetNode(node: Node_2): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<LinkingInputDirective, "[ngDiagramLinkingInput]", never, { "portId": { "alias": "portId"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<LinkingInputDirective, never>;
}

// Warning: (ae-internal-missing-underscore) The name "loggerMiddleware" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const loggerMiddleware: Middleware;

// @public
export interface Metadata<T extends DataObject = DataObject> {
    data?: T;
    viewport: Viewport;
}

// @public
export interface Middleware<TName extends string = string> {
    execute: (context: MiddlewareContext, next: (stateUpdate?: FlowStateUpdate) => Promise<FlowState>, cancel: () => void) => Promise<void> | void;
    name: TName;
}

// @public
export type MiddlewareChain = Middleware[];

// @public
export interface MiddlewareContext {
    actionStateManager: ActionStateManager;
    config: FlowConfig;
    edgeRoutingManager: EdgeRoutingManager;
    edgesMap: Map<string, Edge>;
    environment: EnvironmentInfo;
    helpers: MiddlewareHelpers;
    history: MiddlewareHistoryUpdate[];
    initialEdgesMap: Map<string, Edge>;
    initialNodesMap: Map<string, Node_2>;
    initialState: FlowState;
    initialUpdate: FlowStateUpdate;
    // @deprecated
    modelActionType: ModelActionType;
    modelActionTypes: ModelActionTypes;
    nodesMap: Map<string, Node_2>;
    state: FlowState;
}

// @public
export interface MiddlewareHelpers {
    anyEdgesAdded: () => boolean;
    anyEdgesRemoved: () => boolean;
    anyNodesAdded: () => boolean;
    anyNodesRemoved: () => boolean;
    checkIfAnyEdgePropsChanged: (props: string[]) => boolean;
    checkIfAnyNodePropsChanged: (props: string[]) => boolean;
    checkIfEdgeAdded: (id: string) => boolean;
    checkIfEdgeChanged: (id: string) => boolean;
    checkIfEdgeRemoved: (id: string) => boolean;
    checkIfNodeAdded: (id: string) => boolean;
    checkIfNodeChanged: (id: string) => boolean;
    checkIfNodeRemoved: (id: string) => boolean;
    getAddedEdges: () => Edge[];
    getAddedNodes: () => Node_2[];
    getAffectedEdgeIds: (props: string[]) => string[];
    getAffectedNodeIds: (props: string[]) => string[];
    getRemovedEdges: () => Edge[];
    getRemovedNodes: () => Node_2[];
}

// @public
export interface MiddlewareHistoryUpdate {
    name: string;
    stateUpdate: FlowStateUpdate;
}

// @public
export type MinimapNodeShape = 'rect' | 'circle' | 'ellipse';

// @public
export interface MinimapNodeStyle {
    cssClass?: string;
    fill?: string;
    opacity?: number;
    shape?: MinimapNodeShape;
    stroke?: string;
    strokeWidth?: number;
}

// @public
export type MinimapNodeStyleFn = (node: Node_2) => MinimapNodeStyle | null | undefined;

// @public (undocumented)
export class MobileBoxSelectionDirective {
    // (undocumented)
    onTouchEnd(event: TouchEvent): void;
    // (undocumented)
    onTouchMove(event: TouchEvent): void;
    // (undocumented)
    onTouchStart(event: TouchEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MobileBoxSelectionDirective, "[ngDiagramMobileBoxSelection]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MobileBoxSelectionDirective, never>;
}

// @public (undocumented)
export class MobilePanningDirective {
    // (undocumented)
    onTouchEnd(event: TouchEvent): void;
    // (undocumented)
    onTouchMove(event: TouchEvent): void;
    // (undocumented)
    onTouchStart(event: TouchEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MobilePanningDirective, "[ngDiagramPanning]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MobilePanningDirective, never>;
}

// @public (undocumented)
export class MobileZoomingDirective {
    // (undocumented)
    onTouchEnd(event: TouchEvent): void;
    // (undocumented)
    onTouchMove(event: TouchEvent): void;
    // (undocumented)
    onTouchStart(event: TouchEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MobileZoomingDirective, "[ngDiagramZoomingPointer]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MobileZoomingDirective, never>;
}

// @public
export interface Model {
    edges: Edge[];
    metadata: Partial<Metadata>;
    nodes: Node_2[];
}

// @public
export type ModelActionType = 'init' | 'changeSelection' | 'moveNodesBy' | 'deleteSelection' | 'addNodes' | 'updateNode' | 'updateNodes' | 'deleteNodes' | 'clearModel' | 'paletteDropNode' | 'addEdges' | 'updateEdge' | 'deleteEdges' | 'deleteElements' | 'paste' | 'moveViewport' | 'resizeNode' | 'startLinking' | 'moveTemporaryEdge' | 'finishLinking' | 'zoom' | 'changeZOrder' | 'rotateNodeTo' | 'highlightGroup' | 'highlightGroupClear' | 'moveNodes' | 'moveNodesStop';

// @public
export type ModelActionTypes = LooseAutocomplete<ModelActionType>[];

// @public
export interface ModelAdapter {
    destroy(): void;
    getEdges(): Edge[];
    getMetadata(): Metadata;
    getNodes(): Node_2[];
    onChange(callback: ({ nodes, edges, metadata }: ModelChanges) => void): void;
    redo(): void;
    toJSON(): string;
    undo(): void;
    unregisterOnChange(callback: ({ nodes, edges, metadata }: ModelChanges) => void): void;
    updateEdges(edges: Edge[]): void;
    // (undocumented)
    updateEdges(edgesFn: (edges: Edge[]) => Edge[]): void;
    updateMetadata(metadata: Metadata): void;
    // (undocumented)
    updateMetadata(metadataFn: (metadata: Metadata) => Metadata): void;
    updateNodes(nodes: Node_2[]): void;
    // (undocumented)
    updateNodes(nodesFn: (nodes: Node_2[]) => Node_2[]): void;
}

// @public
export interface ModelChanges {
    edges: Edge[];
    metadata: Metadata;
    nodes: Node_2[];
}

// @public
export interface ModifierOnlyShortcutBinding {
    key?: never;
    modifiers: Partial<InputModifiers>;
}

// @public
export class NgDiagramBackgroundComponent implements AfterContentInit {
    // (undocumented)
    protected hasContent: boolean;
    // @internal (undocumented)
    protected isDottedBackground: Signal<boolean>;
    // @internal (undocumented)
    ngAfterContentInit(): void;
    type: InputSignal<"grid" | "dots">;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramBackgroundComponent, "ng-diagram-background", never, { "type": { "alias": "type"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramBackgroundComponent, never>;
}

// @public
export class NgDiagramBaseEdgeComponent {
    constructor();
    // (undocumented)
    readonly class: Signal<string>;
    edge: InputSignal<Edge<object>>;
    // (undocumented)
    readonly labels: Signal<EdgeLabel[]>;
    // (undocumented)
    readonly markerEnd: Signal<string | null>;
    // (undocumented)
    readonly markerStart: Signal<string | null>;
    // (undocumented)
    readonly path: Signal<string>;
    // (undocumented)
    readonly points: Signal<Point[]>;
    routing: InputSignal<string | undefined>;
    // (undocumented)
    readonly selected: Signal<boolean | undefined>;
    sourceArrowhead: InputSignal<string | undefined>;
    // (undocumented)
    readonly sourceMarkerId: Signal<string | undefined>;
    stroke: InputSignal<string | undefined>;
    strokeDasharray: InputSignal<string | undefined>;
    strokeOpacity: InputSignal<number | undefined>;
    strokeWidth: InputSignal<number | undefined>;
    targetArrowhead: InputSignal<string | undefined>;
    // (undocumented)
    readonly targetMarkerId: Signal<string | undefined>;
    // (undocumented)
    readonly temporary: Signal<boolean | undefined>;
    readonly useInlineMarkers: boolean;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramBaseEdgeComponent, "ng-diagram-base-edge", never, { "edge": { "alias": "edge"; "required": true; "isSignal": true; }; "routing": { "alias": "routing"; "required": false; "isSignal": true; }; "stroke": { "alias": "stroke"; "required": false; "isSignal": true; }; "sourceArrowhead": { "alias": "sourceArrowhead"; "required": false; "isSignal": true; }; "targetArrowhead": { "alias": "targetArrowhead"; "required": false; "isSignal": true; }; "strokeOpacity": { "alias": "strokeOpacity"; "required": false; "isSignal": true; }; "strokeWidth": { "alias": "strokeWidth"; "required": false; "isSignal": true; }; "strokeDasharray": { "alias": "strokeDasharray"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, [{ directive: typeof i1_2.ZIndexDirective; inputs: { "data": "edge"; }; outputs: {}; }, { directive: typeof i11.EdgeSelectionDirective; inputs: { "targetData": "edge"; }; outputs: {}; }]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramBaseEdgeComponent, never>;
}

// @public
export class NgDiagramBaseEdgeLabelComponent implements OnInit, OnDestroy {
    constructor();
    // (undocumented)
    readonly edgeData: Signal<Edge<object>>;
    // (undocumented)
    readonly edgeId: Signal<string>;
    id: InputSignal<string>;
    // (undocumented)
    readonly isVisible: Signal<boolean>;
    // @internal (undocumented)
    ngOnDestroy(): void;
    // @internal (undocumented)
    ngOnInit(): void;
    // (undocumented)
    readonly points: Signal<Point[] | undefined>;
    // (undocumented)
    readonly position: Signal<Point>;
    positionOnEdge: InputSignal<number>;
    // (undocumented)
    get transform(): string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramBaseEdgeLabelComponent, "ng-diagram-base-edge-label", never, { "id": { "alias": "id"; "required": true; "isSignal": true; }; "positionOnEdge": { "alias": "positionOnEdge"; "required": true; "isSignal": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramBaseEdgeLabelComponent, never>;
}

// @public
export class NgDiagramBaseNodeTemplateComponent implements NgDiagramNodeTemplate {
    // (undocumented)
    classes: Signal<string>;
    // (undocumented)
    enablePortHover: Signal<boolean>;
    // (undocumented)
    isSelected: Signal<boolean>;
    // (undocumented)
    node: InputSignal<Node_2>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramBaseNodeTemplateComponent, "ng-diagram-base-node-template", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramBaseNodeTemplateComponent, never>;
}

// @public
export class NgDiagramClipboardService extends NgDiagramBaseService {
    copy(): void;
    cut(): void;
    paste(position: Point): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramClipboardService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramClipboardService>;
}

// @public
export class NgDiagramComponent implements OnInit, OnDestroy {
    constructor();
    // (undocumented)
    castToGroupNode(node: Node_2): GroupNode;
    clipboardPasted: EventEmitter<ClipboardPastedEvent>;
    config: InputSignal<DeepPartial<FlowConfig> | undefined>;
    diagramInit: EventEmitter<DiagramInitEvent>;
    edgeDrawn: EventEmitter<EdgeDrawnEvent>;
    // (undocumented)
    readonly edges: WritableSignal<Edge<object>[]>;
    edgeTemplateMap: InputSignal<NgDiagramEdgeTemplateMap>;
    // (undocumented)
    getBoundingClientRect(): DOMRect;
    // (undocumented)
    getEdgeTemplate(edgeType: Edge['type']): Type<NgDiagramEdgeTemplate<any>> | null;
    getNodeTemplate(nodeType: Node_2['type']): Type<NgDiagramNodeTemplate<any, SimpleNode<any>>> | Type<NgDiagramGroupNodeTemplate<any>> | null;
    groupMembershipChanged: EventEmitter<GroupMembershipChangedEvent>;
    // (undocumented)
    isGroup(node: Node_2): node is GroupNode<object>;
    middlewares: InputSignal<MiddlewareChain>;
    model: InputSignal<ModelAdapter>;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    nodeResized: EventEmitter<NodeResizedEvent>;
    // (undocumented)
    readonly nodes: WritableSignal<Node_2[]>;
    nodeTemplateMap: InputSignal<NgDiagramNodeTemplateMap>;
    paletteItemDropped: EventEmitter<PaletteItemDroppedEvent>;
    selectionChanged: EventEmitter<SelectionChangedEvent>;
    selectionMoved: EventEmitter<SelectionMovedEvent>;
    selectionRemoved: EventEmitter<SelectionRemovedEvent>;
    selectionRotated: EventEmitter<SelectionRotatedEvent>;
    // (undocumented)
    trackNode: (_index: number, node: Node_2) => any;
    // (undocumented)
    readonly viewport: WritableSignal<Viewport>;
    viewportChanged: EventEmitter<ViewportChangedEvent>;
    readonly viewportPannable: WritableSignal<boolean>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramComponent, "ng-diagram", never, { "config": { "alias": "config"; "required": false; "isSignal": true; }; "model": { "alias": "model"; "required": true; "isSignal": true; }; "middlewares": { "alias": "middlewares"; "required": false; "isSignal": true; }; "nodeTemplateMap": { "alias": "nodeTemplateMap"; "required": false; "isSignal": true; }; "edgeTemplateMap": { "alias": "edgeTemplateMap"; "required": false; "isSignal": true; }; }, { "diagramInit": "diagramInit"; "edgeDrawn": "edgeDrawn"; "selectionMoved": "selectionMoved"; "selectionChanged": "selectionChanged"; "selectionRemoved": "selectionRemoved"; "groupMembershipChanged": "groupMembershipChanged"; "selectionRotated": "selectionRotated"; "viewportChanged": "viewportChanged"; "clipboardPasted": "clipboardPasted"; "nodeResized": "nodeResized"; "paletteItemDropped": "paletteItemDropped"; }, never, ["ng-diagram-background"], true, [{ directive: typeof i1.NgDiagramServicesAvailabilityCheckerDirective; inputs: {}; outputs: {}; }, { directive: typeof i2.BoxSelectionDirective; inputs: {}; outputs: {}; }, { directive: typeof i3.MobileBoxSelectionDirective; inputs: {}; outputs: {}; }, { directive: typeof i4.CursorPositionTrackerDirective; inputs: {}; outputs: {}; }, { directive: typeof i5.ZoomingWheelDirective; inputs: {}; outputs: {}; }, { directive: typeof i6.PanningDirective; inputs: {}; outputs: {}; }, { directive: typeof i7.MobilePanningDirective; inputs: {}; outputs: {}; }, { directive: typeof i8.MobileZoomingDirective; inputs: {}; outputs: {}; }, { directive: typeof i9.KeyboardInputsDirective; inputs: {}; outputs: {}; }, { directive: typeof i10.PaletteDropDirective; inputs: {}; outputs: {}; }, { directive: typeof i11.DiagramSelectionDirective; inputs: {}; outputs: {}; }]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramComponent, never>;
}

// @public
export type NgDiagramConfig = DeepPartial<FlowConfig>;

// @public
export interface NgDiagramEdgeTemplate<Data extends DataObject = DataObject> {
    edge: InputSignal<Edge<Data>>;
}

// @public
export class NgDiagramEdgeTemplateMap extends Map<string, Type<NgDiagramEdgeTemplate<any>>> {
}

// @public
export class NgDiagramGroupHighlightedDirective {
    // (undocumented)
    protected readonly highlighted: Signal<boolean>;
    node: InputSignal<GroupNode<object>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgDiagramGroupHighlightedDirective, "[ngDiagramGroupHighlighted]", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramGroupHighlightedDirective, never>;
}

// @public
export interface NgDiagramGroupNodeTemplate<Data extends DataObject = DataObject> extends NgDiagramNodeTemplate<Data, GroupNode<Data>> {
}

// @public
export class NgDiagramGroupsService extends NgDiagramBaseService {
    addToGroup(groupId: string, nodeIds: string[]): void;
    highlightGroup(groupId: string, nodes: Node_2[]): void;
    highlightGroupClear(): void;
    removeFromGroup(groupId: string, nodeIds: string[]): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramGroupsService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramGroupsService>;
}

// @public
export class NgDiagramMarkerComponent implements AfterViewInit {
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramMarkerComponent, "ng-diagram-marker", never, {}, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramMarkerComponent, never>;
}

// Warning: (ae-internal-missing-underscore) The name "NgDiagramMath" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const NgDiagramMath: {
    angleBetweenPoints: typeof angleBetweenPoints;
    angleToSide: (angleDegrees: number, inverse?: boolean) => PortSide;
    clamp: ({ min, value, max }: {
        min: number;
        value: number;
        max: number;
    }) => number;
    distanceBetweenPoints: (a: Point, b: Point) => number;
    normalizeAngle: (angle: number) => number;
    snapAngle: typeof snapAngle;
    snapNumber: (value: number, step: number) => number;
    snapPoint: (point: Point, step: Size) => {
        x: number;
        y: number;
    };
    calculateEdgePanningForce: (containerBox: Rect, clientPosition: Point, detectionThreshold: number, forceMultiplier: number) => Point | null;
};

// @public
export class NgDiagramMinimapComponent implements AfterViewInit {
    // (undocumented)
    protected diagramBounds: Signal<Rect>;
    // (undocumented)
    hasValidViewport: Signal<boolean>;
    height: InputSignal<number>;
    // (undocumented)
    isDiagramInitialized: WritableSignal<boolean>;
    // @internal
    protected minimapNodes: Signal<MinimapNodeData[]>;
    minimapNodeTemplateMap: InputSignal<NgDiagramMinimapNodeTemplateMap>;
    // (undocumented)
    ngAfterViewInit(): void;
    // @internal
    protected nodesGroupTransform: Signal<string>;
    nodeStyle: InputSignal<MinimapNodeStyleFn | undefined>;
    position: InputSignal<NgDiagramPanelPosition>;
    // @internal
    protected showDiagramBounds: Signal<boolean>;
    showZoomControls: InputSignal<boolean>;
    // @internal
    protected transform: Signal<MinimapTransform>;
    // (undocumented)
    viewport: WritableSignal<Viewport>;
    // (undocumented)
    viewportRect: Signal<MinimapViewportRect>;
    width: InputSignal<number>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramMinimapComponent, "ng-diagram-minimap", never, { "position": { "alias": "position"; "required": false; "isSignal": true; }; "width": { "alias": "width"; "required": false; "isSignal": true; }; "height": { "alias": "height"; "required": false; "isSignal": true; }; "showZoomControls": { "alias": "showZoomControls"; "required": false; "isSignal": true; }; "nodeStyle": { "alias": "nodeStyle"; "required": false; "isSignal": true; }; "minimapNodeTemplateMap": { "alias": "minimapNodeTemplateMap"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramMinimapComponent, never>;
}

// @public
export class NgDiagramMinimapNavigationDirective implements OnDestroy {
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    onPointerDown(event: PointerEvent): void;
    // (undocumented)
    transform: InputSignal<MinimapTransform>;
    // (undocumented)
    viewport: InputSignal<Viewport>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgDiagramMinimapNavigationDirective, "[ngDiagramMinimapNavigation]", never, { "transform": { "alias": "transform"; "required": true; "isSignal": true; }; "viewport": { "alias": "viewport"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramMinimapNavigationDirective, never>;
}

// @public
export interface NgDiagramMinimapNodeTemplate {
    node: InputSignal<Node_2>;
    nodeStyle: InputSignal<MinimapNodeStyle | undefined>;
}

// @public
export class NgDiagramMinimapNodeTemplateMap extends Map<string, Type<NgDiagramMinimapNodeTemplate>> {
}

// @public
export class NgDiagramModelService extends NgDiagramBaseService implements OnDestroy {
    constructor();
    addEdges(edges: Edge[]): void;
    addNodes(nodes: Node_2[]): void;
    computePartsBounds(nodes: Node_2[], edges: Edge[]): Rect;
    deleteEdges(ids: string[]): void;
    deleteNodes(ids: string[]): void;
    readonly edges: Signal<Edge<object>[]>;
    getChildren(groupId: string): Node_2[];
    getChildrenNested(groupId: string): Node_2[];
    getConnectedEdges(nodeId: string): Edge[];
    getConnectedNodes(nodeId: string): Node_2[];
    getEdgeById(edgeId: string): Edge | null;
    getModel(): ModelAdapter;
    getNearestNodeInRange(point: Point, range: number): Node_2 | null;
    getNearestPortInRange(point: Point, range: number): Port | null;
    getNodeById(nodeId: string): Node_2 | null;
    getNodeEnds(edgeId: string): {
        source: Node_2;
        target: Node_2;
    } | null;
    getNodesInRange(point: Point, range: number): Node_2[];
    getOverlappingNodes(nodeId: string): Node_2[];
    getOverlappingNodes(node: Node_2): Node_2[];
    getParentHierarchy(nodeId: string): GroupNode[];
    isNestedChild(nodeId: string, groupId: string): boolean;
    readonly metadata: Signal<Metadata<object>>;
    // @internal
    ngOnDestroy(): void;
    readonly nodes: Signal<Node_2[]>;
    toJSON(): string;
    updateEdge(edgeId: string, edge: Partial<Edge>): void;
    updateEdgeData<T extends Record<string, unknown> | undefined>(edgeId: string, data: T): void;
    updateEdges(edges: (Pick<Edge, 'id'> & Partial<Edge>)[]): void;
    updateNode(nodeId: string, node: Partial<Node_2>): void;
    updateNodeData<T extends Record<string, unknown> | undefined>(nodeId: string, data: T): void;
    updateNodes(nodes: (Pick<Node_2, 'id'> & Partial<Node_2>)[]): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramModelService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramModelService>;
}

// @public
export class NgDiagramNodeResizeAdornmentComponent extends NodeContextGuardBase {
    // (undocumented)
    readonly dataResizable: Signal<boolean | undefined>;
    defaultResizable: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly handlePositions: HandlePosition[];
    // (undocumented)
    readonly isResizable: Signal<boolean | undefined>;
    // (undocumented)
    readonly linePositions: LinePosition[];
    // (undocumented)
    readonly nodeData: Signal<Node_2 | undefined>;
    // (undocumented)
    readonly showAdornment: Signal<boolean | undefined>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramNodeResizeAdornmentComponent, "ng-diagram-node-resize-adornment", never, { "defaultResizable": { "alias": "defaultResizable"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramNodeResizeAdornmentComponent, never>;
}

// @public
export class NgDiagramNodeRotateAdornmentComponent extends NodeContextGuardBase {
    // (undocumented)
    readonly dataRotatable: Signal<boolean | undefined>;
    defaultRotatable: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly eventTarget: Signal<    {
    type: "rotate-handle";
    element: Node_2 | undefined;
    }>;
    // (undocumented)
    readonly isRotatable: Signal<boolean | undefined>;
    // (undocumented)
    readonly isRotating: WritableSignal<boolean>;
    // (undocumented)
    readonly nodeData: Signal<Node_2 | undefined>;
    // (undocumented)
    readonly showAdornment: Signal<boolean>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramNodeRotateAdornmentComponent, "ng-diagram-node-rotate-adornment", never, { "defaultRotatable": { "alias": "defaultRotatable"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramNodeRotateAdornmentComponent, never>;
}

// @public
export class NgDiagramNodeSelectedDirective {
    node: InputSignal<Node_2>;
    // (undocumented)
    protected readonly selected: Signal<boolean>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgDiagramNodeSelectedDirective, "[ngDiagramNodeSelected]", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramNodeSelectedDirective, never>;
}

// @public
export class NgDiagramNodeService extends NgDiagramBaseService {
    bringToFront(nodeIds?: string[], edgeIds?: string[]): void;
    moveNodesBy(nodes: Node_2[], delta: Point): void;
    resizeNode(id: string, size: Size, position?: Point, disableAutoSize?: boolean): void;
    rotateNodeTo(nodeId: string, angle: number): void;
    sendToBack(nodeIds?: string[], edgeIds?: string[]): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramNodeService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramNodeService>;
}

// @public
export interface NgDiagramNodeTemplate<Data extends DataObject = DataObject, NodeType extends Node_2<Data> = SimpleNode<Data>> {
    node: InputSignal<NodeType>;
}

// @public
export class NgDiagramNodeTemplateMap extends Map<string, Type<NgDiagramNodeTemplate<any>> | Type<NgDiagramGroupNodeTemplate<any>>> {
}

// @public
export type NgDiagramPaletteItem<Data extends object = BasePaletteItemData> = SimpleNodeData<Data> | GroupNodeData<Data>;

// @public
export class NgDiagramPaletteItemComponent {
    item: InputSignal<NgDiagramPaletteItem>;
    // @internal (undocumented)
    onDragStart(event: DragEvent): void;
    // @internal (undocumented)
    onMouseDown(): void;
    // @internal (undocumented)
    onTouchStart(event: TouchEvent): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramPaletteItemComponent, "ng-diagram-palette-item", never, { "item": { "alias": "item"; "required": true; "isSignal": true; }; }, {}, ["paletteItemPreviewComponent"], ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramPaletteItemComponent, never>;
}

// @public
export class NgDiagramPaletteItemPreviewComponent {
    // (undocumented)
    readonly id: string;
    // (undocumented)
    protected readonly isChrome: boolean;
    // (undocumented)
    protected readonly isSafari: boolean;
    // (undocumented)
    protected readonly isVisible: Signal<boolean>;
    // (undocumented)
    readonly preview: Signal<ElementRef<HTMLElement> | undefined>;
    // (undocumented)
    protected readonly scale: Signal<number>;
    // (undocumented)
    get scaleTransform(): string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramPaletteItemPreviewComponent, "ng-diagram-palette-item-preview", never, {}, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramPaletteItemPreviewComponent, never>;
}

// @public
export type NgDiagramPanelPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';

// @public
export class NgDiagramPortComponent extends NodeContextGuardBase implements OnInit, OnDestroy, AfterContentInit {
    constructor();
    // (undocumented)
    protected hasContent: boolean;
    id: InputSignal<string>;
    // (undocumented)
    protected readonly isInitialized: WritableSignal<boolean>;
    // (undocumented)
    protected readonly lastSide: WritableSignal<PortSide | undefined>;
    // (undocumented)
    protected readonly lastType: WritableSignal<"source" | "target" | "both" | undefined>;
    // @internal (undocumented)
    ngAfterContentInit(): void;
    // @internal (undocumented)
    ngOnDestroy(): void;
    // @internal (undocumented)
    ngOnInit(): void;
    // (undocumented)
    protected readonly nodeData: Signal<Node_2 | undefined>;
    originPoint: InputSignal<OriginPoint>;
    // (undocumented)
    get portClass(): string;
    side: InputSignal<PortSide>;
    type: InputSignal<"source" | "target" | "both">;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<NgDiagramPortComponent, "ng-diagram-port", never, { "id": { "alias": "id"; "required": true; "isSignal": true; }; "type": { "alias": "type"; "required": true; "isSignal": true; }; "side": { "alias": "side"; "required": true; "isSignal": true; }; "originPoint": { "alias": "originPoint"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, [{ directive: typeof i1_4.LinkingInputDirective; inputs: { "portId": "id"; }; outputs: {}; }]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramPortComponent, never>;
}

// @public
export class NgDiagramSelectionService extends NgDiagramBaseService {
    deleteSelection(): void;
    deselect(nodeIds?: string[], edgeIds?: string[]): void;
    deselectAll(): void;
    select(nodeIds?: string[], edgeIds?: string[]): void;
    selection: Signal<    {
    nodes: Node_2[];
    edges: Edge<object>[];
    }>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramSelectionService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramSelectionService>;
}

// @public
export class NgDiagramService extends NgDiagramBaseService {
    constructor();
    readonly actionState: Signal<Readonly<ActionState>>;
    addEventListener<K extends keyof DiagramEventMap>(event: K, callback: EventListener_2<DiagramEventMap[K]>): UnsubscribeFn;
    addEventListenerOnce<K extends keyof DiagramEventMap>(event: K, callback: EventListener_2<DiagramEventMap[K]>): UnsubscribeFn;
    areEventsEnabled(): boolean;
    readonly config: Signal<Readonly<DeepPartial<FlowConfig>>>;
    getDefaultRouting(): string;
    getEnvironment(): EnvironmentInfo;
    getRegisteredRoutings(): string[];
    hasEventListeners(event: keyof DiagramEventMap): boolean;
    isInitialized: Signal<boolean>;
    registerMiddleware(middleware: Middleware): () => void;
    registerRouting(routing: EdgeRouting): void;
    removeAllEventListeners(): void;
    removeEventListener<K extends keyof DiagramEventMap>(event: K, callback?: EventListener_2<DiagramEventMap[K]>): void;
    setDefaultRouting(name: string): void;
    setEventsEnabled(enabled: boolean): void;
    startLinking(node: Node_2, portId?: string): void;
    transaction(callback: () => Promise<void>): Promise<TransactionResult>;
    transaction(callback: () => Promise<void>, options: TransactionOptions): Promise<TransactionResult>;
    transaction(callback: () => void): void;
    transaction(callback: () => void, options: TransactionOptions): Promise<TransactionResult>;
    unregisterMiddleware(name: string): void;
    unregisterRouting(name: string): void;
    updateConfig(config: Partial<NgDiagramConfig>): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NgDiagramService>;
}

// @public (undocumented)
export class NgDiagramServicesAvailabilityCheckerDirective {
    constructor();
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgDiagramServicesAvailabilityCheckerDirective, "[ngDiagramServicesAvailabilityChecker]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NgDiagramServicesAvailabilityCheckerDirective, never>;
}

// @public
export class NgDiagramViewportService extends NgDiagramBaseService {
    canZoomIn: Signal<boolean>;
    canZoomOut: Signal<boolean>;
    centerOnNode(nodeOrId: string | Node_2): void;
    centerOnRect(rect: Rect): void;
    clientToFlowPosition(clientPosition: Point): Point;
    clientToFlowViewportPosition(clientPosition: Point): Point;
    flowToClientPosition(flowPosition: Point): Point;
    get maxZoom(): number;
    get minZoom(): number;
    moveViewport(x: number, y: number): void;
    moveViewportBy(dx: number, dy: number): void;
    scale: Signal<number>;
    viewport: Signal<Viewport>;
    zoom(factor: number, center?: Point | undefined): void;
    zoomToFit(options?: {
        nodeIds?: string[];
        edgeIds?: string[];
        padding?: number | [number, number] | [number, number, number] | [number, number, number, number];
    }): void;
}

// @public
type Node_2<T extends DataObject = DataObject> = SimpleNode<T> | GroupNode<T>;
export { Node_2 as Node }

// @public (undocumented)
export class NodePositionDirective {
    // (undocumented)
    node: InputSignal<Node_2>;
    // (undocumented)
    position: Signal<Point>;
    // (undocumented)
    get transform(): string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NodePositionDirective, "[ngDiagramNodePosition]", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NodePositionDirective, never>;
}

// @public
export interface NodeResizedEvent {
    node: Node_2;
    previousSize: Size;
}

// @public
export interface NodeRotationConfig {
    computeSnapAngleForNode: (node: Node_2) => number | null;
    defaultRotatable: boolean;
    defaultSnapAngle: number;
    shouldSnapForNode: (node: Node_2) => boolean;
}

// @public (undocumented)
export class NodeSelectionDirective extends ObjectSelectionDirective {
    // (undocumented)
    readonly targetData: InputSignal<Edge<object> | Node_2 | undefined>;
    // (undocumented)
    targetType: BasePointerInputEvent['targetType'];
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NodeSelectionDirective, never, never, { "targetData": { "alias": "targetData"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NodeSelectionDirective, never>;
}

// Warning: (ae-internal-missing-underscore) The name "NodeSizeDirective" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class NodeSizeDirective implements OnDestroy, OnInit {
    constructor();
    // (undocumented)
    autoSize: Signal<boolean>;
    // (undocumented)
    id: Signal<string>;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    node: InputSignal<Node_2>;
    // (undocumented)
    size: Signal<Size | undefined>;
    // (undocumented)
    sizeState: Signal<    {
    size: Size | undefined;
    autoSize: boolean;
    }>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NodeSizeDirective, "[ngDiagramNodeSize]", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NodeSizeDirective, never>;
}

// @public
export type OriginPoint = 'topLeft' | 'topCenter' | 'topRight' | 'centerLeft' | 'center' | 'centerRight' | 'bottomLeft' | 'bottomCenter' | 'bottomRight';

// @public (undocumented)
export class PaletteDropDirective implements OnInit, OnDestroy {
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    onDragOver(event: DragEvent): void;
    // (undocumented)
    onDrop(event: DragEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<PaletteDropDirective, "[ngDiagramPaletteDrop]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<PaletteDropDirective, never>;
}

// @public
export interface PaletteItemDroppedEvent {
    dropPosition: Point;
    node: Node_2;
}

// @public (undocumented)
export class PanningDirective implements OnDestroy {
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    onPointerDown(event: PointerInputEvent): void;
    // (undocumented)
    onPointerUp: (event: PointerEvent) => void;
    // (undocumented)
    onWheel(event: WheelInputEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<PanningDirective, "[ngDiagramPanning]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<PanningDirective, never>;
}

// @public
export interface Point {
    x: number;
    y: number;
}

// @public
export interface PointerInputEvent extends PointerEvent {
    // (undocumented)
    boxSelectionHandled?: boolean;
    // (undocumented)
    linkingHandled?: boolean;
    // (undocumented)
    moveSelectionHandled?: boolean;
    // (undocumented)
    rotateHandled?: boolean;
    // (undocumented)
    selectHandled?: boolean;
    // (undocumented)
    zoomingHandled?: boolean;
}

// @public
export type PointerOnlyActionName = 'multiSelection' | 'boxSelection';

// @public
export interface PointerOnlyShortcutDefinition {
    actionName: PointerOnlyActionName;
    bindings: ModifierOnlyShortcutBinding[];
}

// @public
export interface Port {
    id: string;
    nodeId: string;
    position?: Point;
    side: PortSide;
    size?: Size;
    type: 'source' | 'target' | 'both';
}

// @public
export type PortLocation = {
    side: PortSide;
} & Point;

// @public
export type PortSide = 'top' | 'right' | 'bottom' | 'left';

// @public
export function provideNgDiagram(): Provider[];

// @public
export interface Rect {
    height: number;
    width: number;
    x: number;
    y: number;
}

// @public
export interface ResizeActionState {
    resizingNode: Node_2;
    startHeight: number;
    startNodePositionX: number;
    startNodePositionY: number;
    startWidth: number;
    startX: number;
    startY: number;
}

// @public
export interface ResizeConfig {
    allowResizeBelowChildrenBounds: boolean;
    defaultResizable: boolean;
    getMinNodeSize: (node: Node_2) => Size;
}

// @public
export interface RotationActionState {
    initialNodeAngle: number;
    nodeId: string;
    startAngle: number;
}

// @public
export type RoutingMode = 'manual' | 'auto';

// @public
export interface SelectionChangedEvent {
    previousEdges: Edge[];
    previousNodes: Node_2[];
    selectedEdges: Edge[];
    selectedNodes: Node_2[];
}

// @public
export interface SelectionMovedEvent {
    nodes: Node_2[];
}

// @public
export interface SelectionMovingConfig {
    edgePanningEnabled: boolean;
    edgePanningForce: number;
    edgePanningThreshold: number;
}

// @public
export interface SelectionRemovedEvent {
    deletedEdges: Edge[];
    deletedNodes: Node_2[];
}

// @public
export interface SelectionRotatedEvent {
    angle: number;
    node: Node_2;
    previousAngle: number;
}

// @public
export type ShortcutActionName = KeyboardActionName | PointerOnlyActionName | WheelOnlyActionName;

// @public
export type ShortcutDefinition = KeyboardShortcutDefinition | PointerOnlyShortcutDefinition | WheelOnlyShortcutDefinition;

// @public
export interface SimpleNode<T extends DataObject = DataObject> {
    angle?: number;
    autoSize?: boolean;
    // (undocumented)
    readonly computedZIndex?: number;
    data: T;
    draggable?: boolean;
    groupId?: Node_2<T>['id'];
    id: string;
    // (undocumented)
    measuredBounds?: Rect;
    // (undocumented)
    readonly measuredPorts?: Port[];
    position: Point;
    resizable?: boolean;
    rotatable?: boolean;
    selected?: boolean;
    size?: Size;
    type?: string;
    zOrder?: number;
}

// @public
export type SimpleNodeData<Data extends object = BasePaletteItemData> = Pick<SimpleNode<Data>, 'type' | 'data' | 'resizable' | 'rotatable' | 'size' | 'angle' | 'autoSize' | 'zOrder'>;

// @public
export interface Size {
    height: number;
    width: number;
}

// @public
export interface SnappingConfig {
    computeSnapForNodeDrag: (node: Node_2) => Size | null;
    computeSnapForNodeSize: (node: Node_2) => Size | null;
    defaultDragSnap: Size;
    defaultResizeSnap: Size;
    shouldSnapDragForNode: (node: Node_2) => boolean;
    shouldSnapResizeForNode: (node: Node_2) => boolean;
}

// @public
export interface TransactionOptions {
    waitForMeasurements?: boolean;
}

// @public
export interface TransactionResult {
    actionTypes: ModelActionTypes;
    commandsCount: number;
    results: FlowStateUpdate;
}

// @public
export interface Viewport {
    height?: number;
    scale: number;
    width?: number;
    x: number;
    y: number;
}

// @public
export interface ViewportChangedEvent {
    previousViewport: Viewport;
    viewport: Viewport;
}

// @public (undocumented)
export class ViewportDirective {
    // (undocumented)
    get transform(): string;
    // (undocumented)
    viewport: InputSignal<Viewport>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<ViewportDirective, "[ngDiagramViewport]", never, { "viewport": { "alias": "viewport"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ViewportDirective, never>;
}

// @public
export interface VirtualizationConfig {
    enabled: boolean;
    idleDelay?: number;
    padding: number;
}

// @public
export interface WheelInputEvent extends WheelEvent {
    // (undocumented)
    zoomingHandled?: boolean;
}

// @public
export type WheelOnlyActionName = 'zoom';

// @public
export interface WheelOnlyShortcutDefinition {
    actionName: WheelOnlyActionName;
    bindings: ModifierOnlyShortcutBinding[];
}

// @public
export interface ZIndexConfig {
    edgesAboveConnectedNodes: boolean;
    elevateOnSelection: boolean;
    enabled: boolean;
    selectedZIndex: number;
    temporaryEdgeZIndex: number;
}

// @public (undocumented)
export class ZIndexDirective {
    // (undocumented)
    data: InputSignal<Edge<object> | Node_2>;
    // (undocumented)
    zIndex: Signal<number>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<ZIndexDirective, "[ngDiagramZIndex]", never, { "data": { "alias": "data"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ZIndexDirective, never>;
}

// @public
export interface ZoomConfig {
    max: number;
    min: number;
    step: number;
    zoomToFit: ZoomToFitConfig;
}

// @public (undocumented)
export class ZoomingWheelDirective {
    // (undocumented)
    onWheel(event: WheelInputEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<ZoomingWheelDirective, "[ngDiagramZoomingWheel]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ZoomingWheelDirective, never>;
}

// (No @packageDocumentation comment for this package)

```
